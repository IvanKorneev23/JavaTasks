package com.company;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;

//тут не трогай
interface ImageOperation {
    int execute(int rgb) throws Exception;
}
//и тут не трогай
interface ImageIteratorCallback {
    void callback(int rgb);
}
//а этот класс особенно не трогай. Трогать можно экземпляр этого класса
class RgbMaster {
    public boolean hasAlphaChannel;
    private BufferedImage image;
    private int width;
    private int height;
    private int[] colors;
    RgbMaster(String path) throws IOException {
        //Делаем объект ImageIO для использования API ввода / вывода изображения.
        image = ImageIO.read(new File(path));
        //Получаем ширину.
        width = image.getWidth();
        //Получаем высоту.
        height = image.getHeight();
        //Получаем массив integer пикселей RGB.
        colors = image.getRGB(0, 0, width, height, null, 0, width * height);
        //Есть ли прозрачность.
        hasAlphaChannel = image.getAlphaRaster() != null;
    }
    static float[] rgbIntToArray(int rgbInt) {
        Color color = new Color(rgbInt);
        return color.getRGBComponents(null); // Получаем массив из цветового int. Вида: [red, green, blue, alpha].
    }
    static int rgbArrayToInt(float[] rgbArray) throws Exception {
        //Получаем цвет в виде int из массива [r,g,b] или [r,g,b,a].
        if (rgbArray.length == 3) {
            return new Color(rgbArray[0], rgbArray[1], rgbArray[2]).getRGB();
        } else if (rgbArray.length == 4) {
            return new Color(rgbArray[0], rgbArray[1], rgbArray[2], rgbArray[3]).getRGB();
        } else {
            throw new Exception("invalid color");
        }
    }
    void changeImage(ImageOperation operation) throws Exception {
        //Проходимся по всем пикселям в картинке и переопределяем значением которое вернула lambda.
        for (int i = 0; i < colors.length; i++) {
            colors[i] = operation.execute(colors[i]);
        }
    }
    void iterateInImage(ImageIteratorCallback operation) {
        //Проходимся по всем пикселям в картинке и вызываем lambd-у с аргументов в виде цвета(int).
        for (int i = 0; i < colors.length; i++) {
            operation.callback(colors[i]);
        }
    }
    void save(String fileName) throws IOException {
        //Проверяем тип с прозрачностью ли картинка, создаём объект который будет хранить картинку и в итоге сохранит её.
        int type = hasAlphaChannel ? BufferedImage.TYPE_INT_ARGB: BufferedImage.TYPE_INT_RGB;
        image = new BufferedImage(width, height, type);
        image.setRGB(0, 0, width, height, colors, 0, width * height);
        ImageIO.write(image, "png", new File(fileName));
    }
}
abstract class ImageFunctions {
    HashMap<Integer, Integer> frequency = new HashMap<>(); //<color, count>
    abstract int greyScale(int color) throws Exception;
    abstract int sepia(int color) throws Exception;
    abstract int inversion(int color) throws Exception;
    abstract int onlyRed(int color) throws Exception;
    abstract int onlyGreen(int color) throws Exception;
    abstract int onlyBlue(int color) throws Exception;
    abstract void fft(int color); //fill frequency map
}

class ImageFunctionsImpl extends ImageFunctions {
    @Override
    int greyScale(int color) throws Exception {
        float[] pixel = RgbMaster.rgbIntToArray(color);
        float avg = (pixel[0] + pixel[1] + pixel[2]) / 3; // чтобы сделать серый скале надо просто взять среднее списка
        return RgbMaster.rgbArrayToInt(new float[] {avg, avg, avg, pixel[3]});
    }
    @Override
    int sepia(int color) throws Exception {
        float[] pixels = RgbMaster.rgbIntToArray(color);
        float[] newPixels = new float[4]; // создаем список с новыми пикселями
        float scale = (float) (.299 * pixels[0] + .587 * pixels[1] + .114 * pixels[2]); // тот самый тон ( цифры из статьи )
        // далее тоже какая-то магия с цифрами, но мне удалось сделать тернарные операторы, я считаю это лучше чем в несколько ифов
        newPixels[0] = (float) ((scale > .8078) ? 1 : scale + .1922);
        newPixels[1] = (float) ((scale < .0549) ? 0 : scale - .0549);
        newPixels[2] = (float) ((scale < .2196) ? 0 : scale - .2196);
        newPixels[3] = pixels[3]; // альфа такая-же как и была
        return RgbMaster.rgbArrayToInt(newPixels);
    }

    @Override
    int inversion(int color) throws Exception { // создали инверсию нашего фото
        float[] pixels = RgbMaster.rgbIntToArray(color); // тоже все по формуле особо нечего объяснять
        pixels[0] = 1 - pixels[0];
        pixels[1] = 1 - pixels[1];
        pixels[2] = 1 - pixels[2];
        return RgbMaster.rgbArrayToInt(pixels);
    }

    @Override
    int onlyRed(int color) throws Exception {
        float[] pixels = RgbMaster.rgbIntToArray(color);
        // Обнуляем зелёный и синий
        pixels[1] = 0;
        pixels[2] = 0;
        return RgbMaster.rgbArrayToInt(pixels);
    }
    @Override
    int onlyGreen(int color) throws Exception {
        float[] pixels = RgbMaster.rgbIntToArray(color);
        // Обнуляем красный и синий
        pixels[0] = 0;
        pixels[2] = 0;
        return RgbMaster.rgbArrayToInt(pixels);
    }
    @Override
    int onlyBlue(int color) throws Exception {
        float[] pixels = RgbMaster.rgbIntToArray(color);
        // Обнуляем красный и зелёный
        pixels[0] = 0;
        pixels[1] = 0;
        return RgbMaster.rgbArrayToInt(pixels);
    }
    @Override
    void fft(int color) {
        frequency.merge(color, 1, Integer::sum); // ну а это тоже по формуле, а так это инкрементация вроде так
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        RgbMaster rbgMaster = new RgbMaster("in_image.png");
        ImageFunctionsImpl imageFunc = new ImageFunctionsImpl();
//        rbgMaster.changeImage(imageFunc::onlyRed);
//        rbgMaster.changeImage(imageFunc::onlyBlue);
//        rbgMaster.changeImage(imageFunc::onlyGreen);
//        rbgMaster.changeImage(imageFunc::greyScale);
        rbgMaster.changeImage(imageFunc::sepia);
//        rbgMaster.changeImage(imageFunc::inversion);
        rbgMaster.save("out_image.png");
//        rbgMaster.iterateInImage(imageFunc::fft);
//        System.out.println(imageFunc.frequency);
    }
}